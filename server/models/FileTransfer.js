/**
 * ============================================
 * FileTransfer Model — P2P File Transfer Tracking
 * ============================================
 * 
 * Tracks metadata for WebRTC DataChannel file transfers.
 * Server NEVER stores file data — only metadata for resume capability.
 * 
 * ARCHITECTURE:
 * - Sender picks a file → creates transfer record
 * - Receiver accepts → WebRTC DataChannel established
 * - File streams chunk-by-chunk through DataChannel (P2P)
 * - Server tracks: which chunks were received (for resume)
 * - If either party disconnects → on reconnect, resume from last chunk
 * 
 * SUPPORTS: Files up to 100GB+ via chunked streaming
 */

const mongoose = require('mongoose');

const fileTransferSchema = new mongoose.Schema({
  // Transfer ID (UUID generated by sender)
  transferId: {
    type: String,
    required: true,
    unique: true,
    index: true,
  },
  // Who is sending
  sender: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true,
  },
  // Who is receiving
  receiver: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true,
  },
  // File metadata (never the actual data)
  fileName: {
    type: String,
    required: true,
    maxlength: 500,
  },
  fileSize: {
    type: Number,       // Total file size in bytes
    required: true,
  },
  fileMimeType: {
    type: String,
    default: 'application/octet-stream',
  },
  // Chunking info
  chunkSize: {
    type: Number,
    default: 65536,     // 64KB default chunk size
  },
  totalChunks: {
    type: Number,
    required: true,
  },
  // Resume tracking — last successfully received chunk index
  lastReceivedChunk: {
    type: Number,
    default: -1,        // -1 means no chunks received yet
  },
  // Bytes transferred so far
  bytesTransferred: {
    type: Number,
    default: 0,
  },
  // File hash for integrity verification (SHA-256 of full file, computed by sender)
  fileHash: {
    type: String,
    default: null,
  },
  // Whether the receiver's hash matched the sender's hash
  hashVerified: {
    type: Boolean,
    default: null,
  },
  // Transfer status
  status: {
    type: String,
    enum: [
      'pending',        // Waiting for receiver to accept
      'accepted',       // Receiver accepted, setting up DataChannel
      'transferring',   // Actively transferring chunks
      'paused',         // Paused (user action or disconnect)
      'completed',      // All chunks received & verified
      'failed',         // Unrecoverable error
      'cancelled',      // Cancelled by either party
      'expired',        // Pending too long without acceptance
    ],
    default: 'pending',
    index: true,
  },
  // Reason for failure/cancellation
  statusReason: {
    type: String,
    default: null,
  },
  // Timestamps for various states
  acceptedAt: {
    type: Date,
    default: null,
  },
  completedAt: {
    type: Date,
    default: null,
  },
  pausedAt: {
    type: Date,
    default: null,
  },
  // Speed tracking
  lastSpeedBps: {
    type: Number,       // Last measured bytes/sec
    default: 0,
  },
}, {
  timestamps: true,     // createdAt, updatedAt
});

// Compound indexes for efficient queries
fileTransferSchema.index({ sender: 1, status: 1, createdAt: -1 });
fileTransferSchema.index({ receiver: 1, status: 1, createdAt: -1 });
fileTransferSchema.index({ transferId: 1, status: 1 });

// Auto-expire pending transfers after 24 hours
fileTransferSchema.index({ createdAt: 1 }, {
  expireAfterSeconds: 86400 * 7,  // Cleanup after 7 days
  partialFilterExpression: {
    status: { $in: ['completed', 'failed', 'cancelled', 'expired'] }
  },
});

/**
 * Get active transfers for a user (both sending and receiving)
 */
fileTransferSchema.statics.getActiveTransfers = function (userId) {
  return this.find({
    $or: [{ sender: userId }, { receiver: userId }],
    status: { $in: ['pending', 'accepted', 'transferring', 'paused'] },
  })
    .sort({ createdAt: -1 })
    .populate('sender', 'username avatar')
    .populate('receiver', 'username avatar');
};

/**
 * Get transfer history for a conversation between two users
 */
fileTransferSchema.statics.getConversationTransfers = function (userId1, userId2) {
  return this.find({
    $or: [
      { sender: userId1, receiver: userId2 },
      { sender: userId2, receiver: userId1 },
    ],
  })
    .sort({ createdAt: -1 })
    .limit(50)
    .populate('sender', 'username avatar')
    .populate('receiver', 'username avatar');
};

module.exports = mongoose.model('FileTransfer', fileTransferSchema);
